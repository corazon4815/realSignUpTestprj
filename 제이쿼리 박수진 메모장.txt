<!-- 인터넷에서 js파일 찾기  --> 
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="http://code.jquery.com/jquery-latest.js"></script> (추천X)

ready 함수
셀렉터


$(function(){
// 이안의 코드를 계속 바꿔가면서 적어주면됨
});   
ex)
	$(function(){
	$("li").css("color","red");
	});
	
id부를때는 #
class부를때는 . 
li * -> li태그와 그 아래태그를 가지고있는 전체
"#second + li" - id가 second에 형제 li태그중에 바로 밑에 나오는애 
"li:first-child" - li태그중에 첫번째 자식(전체 문서가아닌 묶여있는 그룹마다)

$("셀렉터").html()
$("셀렉터").html("<p>text</p>); ->해당태그의 텍스트에 태그를 줌 
$("셀렉터").text()  ->해당 태그 안의 텍스트만 가져옴 
★★★$("셀렉터").append("<p>text</p>")  ->튓부분에 삽입

★Attribute : 태그의 속성
<input type ="checkbox" name ="box" checked ="checked">

★Property : 자바스크립트 객체의 속성
document.getElementById("box").checked

<이벤트 구조>
$(function(){
	$("셀렉터").이벤트(function(){
		이벤트가 발생한 시점에 실행할 문장
	});
});

ex)
$("img").attr("src","sea.jpg").attr("alt","바다");    
  태그의       src의 속성을 sea로 변경  alt의 속성을 바다로 변경 
  
  
<a href="sea.jpg">화면을 변경</a>
앵커태그 클릭시 하이퍼링크 이동 

"javascript:void(0)"->자바스크립트 동작시키지않겠다 의미(=return false)

ex)$("a:eq(0)").click(function(){        ->"a:eq(0)": 앵커태그0번째
$("img").attr("src","flower.jpg").attr("alt","꽃");

<on>
$(function(){       
//"a" : 이벤트가 발생할 애 ->앵커태그에 클릭이벤트가 발생할때 
	$(ul).on("click","a",function(){
         //발생할이벤트         $("img").attr("src",$(this).attr("href")).attr("alt",$(this).text());
		return false;
	});
	$("button").click(function(){
		$("ul").append("<li><a href='Building.jpg'>건물</a></li>");
	});
});

                
$("ul").on("click","a",function(){
         //발생할 이벤트
		$("img").attr("src",$(this).attr("href")).attr("alt",$(this).text());
		return false;


:password ->input태그의 타입이 password인애
:file ->input태그의 타입이 file인애

<prop vs attr>
$(":checkbox").prop("checked","true");
$(":checkbox").attr("checked","true");
//attr : 모든 체크박스를 가져옴 (태그자체를 의미 
문자열엔 checked라고 돼있지만 풀리는 상태임-> 이 상태에서 checked를 줘도
이미 checked라는 문자열이 들어있으니까 check가 안됨
★★★
prop로 뽑아오면 -> 프로토콜부터 다뽑아옴
attr로 뽑아오면 -> 태그에 명시돼있는 값만 뽑아옴

★★★<label의 for, input의 id는 같은 이름으로 하기>

$(":radio").click(function(){
		$("label").css("font-weight",""); 
		->font-weight을 초기화("")(둘다 초기화 시켜놓고 하는게 편하니까 초기화시킴
		$("label[for='"+$(this).attr("id")+"']").css("font-weight","bold");
	});
	
<change>  ->선택된 값이 달라지면 
$(":radio").change(function(){
		$("label").css("font-weight","");
		$("label[for='"+$(this).attr("id")+"']").css("font-weight","bold");                //지금 선택된 label 
	});
	
- each(): 여러개의 태그 집합에서 하나씩 꺼내서 처리(반복문)
꺼내온 태그는 $(this)로 다룬다.
$(:checkbox).each(function(){
    $(this).명령어;
    });

ex)
$("table tr").each(function(){
$(this).html("<td>"+$("th",this).text()+"는"+$("td",this).text()+"</td>");
	});
첫번째 tr을 꺼내오고 다음 tr을 계속해서 for문처럼 꺼내옴
this는 table의 tr을 말함

ex)
$("label,:checkbox").click(function(){
		$("label").css("background","");
		$(":checked").each(function(){
			//:checked : 체크된 체크박스를 가져옴 
			$("label[for='"+$(this).attr("id")+"']").css("background","#CCC");
		});
	});

<disable>
ex)
	$("select").change(function(){
		var x = $(":selected").attr("value");
	if(x=="10 대" || x==" 선택해주세요" ||x=="40 대이상"){
		//선택된 옵션태그를 가져와서 벨류값을 꺼내옴  attr("value")대신 val()써도됨
		$("input").attr("disabled", "disabled");
	}else             
		$("input").removeAttr("disabled");
	
	});
	
<jquery 애니메이션 효과 구조>

$(셀렉터).명령어([ “속도” ], [콜백함수] );     //속도, 콜백함수 생략가능 

<slow, hide>
$("button#show").click(function(){
		$("div").show("slow");
	});
	$("button#hide").click(function(){
		$("div").hide("slow"); //w,h를 0으로 바꾸고 display를 none까지 만듦 
	});

<애니메이션이 동작중일땐 펑션이 실행되지 않게> 
ex) $("div:not(:animated)").hide("slow");

display : inline -기본값으로 요소를 inline요소처럼 표시함
                앞뒤로 줄바꿈x
          block - 줄바꿈이 됨
          none - 박스가 생성되지 않음
                 공간을 차지하지않음
          inline-block - 요소는 inline인데 내부는 block처럼 표시
                         즉 박스 모양이 inline처럼 옆으로 늘어섬
                         
<animate() :: 독자적인 에니메이션 효과 작성>
$(셀렉터).animate(값을 변경하고 싶은 css속성:값, 속도, 움직임, 콜백함수 );
	단 속성은 수식(px,em,%)으로 입력할 수 있는 것만 가능.
	움직임 : swing(점점 빠르게) , linear(일정한 속도)
	
<줄바꾸는 부분 주석처리하기>
<!-- -->

<Ajax> -갯수 제한 6개
Ajax를 사용하면 웹 페이지나 애플리케이션에서 정말로 필요한 데이터, 
서버에서 받아와야 하는 데이터만 요청하기 때문에 데이터 이용량은 줄어들고, 
작은 부분만 업데이트하고, 페이지 새로고침을 기다리는 시간도 줄어들었다. 

<Ajax 기본함수>
(제이쿼리 주소 써놓고해야함)
$.ajax({옵션속성:값}); // jQuery.ajax();

★8. success: 응답이 성공 상태 코드를 반환하면 호출되는 함수. 응답 본문은 이 함수의 첫 번째 매개변수로 전달되며, dataType 프로퍼티에 명시한 형태로 구성. 두번째 매개변수는 상태값을 나타내는 문자열이며, 이 경우에는 항상 success다(Function) 

ex)
if ($(this).find("option:selected").index() > 0) {
선택하세요가 0번인덱스니까 그 아래 옵션을 선택했다면 

CGI방식 : 웹서버가 모두 처리해서 대량 트래픽 발생시 불리
어플리케이션 서버 방식 : 웹서버는 어플리케이션서버에만 전달하면 
되기때문에 전체적안 처리량 높음

<WAS> : 웹 어플리케이션 서버 
ex) 웹서버 : apache 
    어플리케이션 : tomcat9.0

Uniform Resource Locator
구성

<URL>
예: http://www.google.com/search?hl=en&q=jsp&aq=f&oq=
프로토콜: http
호스트: www.google.com
포트: 80 (http 프로토콜의 기본 포트)     --> 기본포트일때 생략가능 
경로: /search                         --> 슬러시 기억하기
쿼리문자열: hl=en&q=jsp&aq=f&oq=

URL은 웹 어플리케이션에 요청을 구분하기 위한 용도로 사용됨

<프로젝트 만들때 톰캣으로 서버 지정못했을때>
properties-> java build path -> add library-> server Runtime
후 next클릭하고 아파치톰캣 클릭  

servelet(서블릿) : 웹 요청을 처리하는 클래스
extends HttpServlet

goGet()
doPost() post 방식일때 
init() : 초기화. 객체 생성 후 바로 한번만 실행  
destroy() : 소멸. 객체가 메모리에서 소멸되기 직전 마지막으로 실행

<doget과 dopost의 매개변수>
HttpServletRequest request : 요청정보를 담고있는 객체
HttpServletResponse response : 클라이언트에게 보낼 응답 데이터를 저장한 객체
★form 태그에 post라고 명시하지않은이상 모두 get방식 

서버 스타트(web.xml) - 클라이언트의 요청 기다림
url로 요청 -> 1. 요청을 처리할 수 있는 서블릿을 찾음
             - 해당 서블릿이 있으면 서블릿이 처리
             2. 서블릿이 없는 경우 path(WebContent)로 전환
해당 경로에 있는 파일을 찾아가서 실행함.

<디렉티브>
- 제공 디렉티브 -
***page : JSP 페이지에 대한 정보를 지정
문서의 타입, 출력 버퍼의 크기, 에러 페이지 등 정보 지정
***taglib : 사용할 태그 라이브러리를 지정

<JSP 디렉티브의 작성 예>
<%@ page contentType="text/html; charset=euc-kr" %>
<%@ page import="java.util.Date" %>

<% %> - 스크립트릿 자바 들어가는 부분 

<html에서 자바클래스를 불러오는 법>
ex)
<%@ page contentType = "text/html; charset=utf-8" %>
<%@ page import ="day0630.Multiply" %>

<html>
<head><title>선언부를 사용한 두 정수값의 곱</title></head>
<body>
<% Multiply m = new Multiply(); %>
	10*25 = <%= m.multiply(10,25) %>

</body>
</html>

★★★<request 기본 객체>
웹 브라우저가 웹 서버에 전송한 요청 관련 정보 제공
<주요 기능>
- ★클라이언트(웹 브라우저)와 관련된 정보 읽기 기능
- 서버와 관련된 정보 읽기 기능
- ★★★클라이언트가 전송한 요청 파라미터 읽기 기능
- 클라이언트가 전송한 요청 헤더 읽기 기능
- 클라이언트가 전송한 쿠키 읽기 기능
- 속성 처리 기능

ContextPath -> 불러오는 경로
http://localhost:8080/chap03/requstInfo.jsp

<request 기본객체 주요제공 메서드>
request.getRemoteAddr()
request.getMethod()
request.getMethod()
request.request.getMethod()

Enumeration : 내장객체 request 에서. getParameterNames()로 모든 인자의 이름을 받을때 Enumeration으로 반환하게 된다.

Map - key, value key값은 중복되면 안됨 순서x 

<파라미터 값 구하기>
request.getParameter

index.jsp?name // name이라는 이름으로 보낸다는 뜻 

서블릿 : 웹요청을 받아서 처리하는 클래스를 만들면 그게 서블릿클래스
Http를 상속받음

<버퍼설정>
<%@ page buffer="8kb" autoFlush="false"%>

war파일 뽑을때 엑스포트 서버파일? 체크하기

<TOC 주요기본객체>
request : 클라이언트의 요청 정보를 저장한다.
response : 응답 정보를 저장한다. 
session : HTTP세션 정보를 저장한다. ★HttpSession

<application 기본객체: 자원구하기>
- 자원 접근 메서드
getRealPath(String path) : (String) 웹 어플리케이션 내에서 지정한 경로에 해당하는 자원의 시스템상에서의 자원 경로를 리턴한다.

getResource(String path) : (url) 웹 어플리케이션 내에서 지정한 경로에 해당하는 자원에 접근할 수 있는 URL 객체를 리턴한다.

getResourceAsStream(String path) : (InputStrean) 웹 어플리케이션 내에서 지정한 경로에 해당하는 자원으로부터 데이터를 읽어올 수 있는 InputStream을 리턴한다.


★★★초기화 파라미터값 저장하기
web.xml에 
 
 <context-param>
  	<param-name>파라미터 이름</param-name>
  	<param-value>파라미터 값</param-value>
  </context-param>
  <context-param>
  	<param-name>port</param-name>
  	<param-value>8080</param-value>
  </context-param>
  
★★★초기화 파라미터값 읽어오기
ex)
<body>

초기화 파라미터 목록:
<ul>
<%
    Enumeration<String> initParamEnum = application.getInitParameterNames();
	while (initParamEnum.hasMoreElements()) {
		String initParamName = initParamEnum.nextElement();
%>
<li><%= initParamName %> = 
    <%= application.getInitParameter(initParamName) %>
<%
	}
%>
</ul>
</body>

★★★<getRealPath(String path) 절대경로>
ex)
<body>

<%
	char[] buff = new char[500];
	int len = -1;
	
	String filePath = "C:\\Users\\Administrator\\Desktop\\psj0619\\worksp\\JinJSP\\WebContent\\0701\\chap06\\message\\notice.txt";
	try(InputStreamReader fr = new InputStreamReader(new FileInputStream(filePath), "UTF-8")) {
		while ((len = fr.read(buff)) != -1) {
			out.print(new String(buff, 0, len));
		}
	} catch(IOException ex) {
		out.println("익셉션 발생: "+ex.getMessage());
	}
%>

</body>

http요청이란 -> url하나하나 

파라미터 - url에 이름(name) 값(value)으로 전달하는 값, String 
속성 - 이름,값 세트 
<속성 관련 메서드>
!!저장!!★★setAttribute - (void) 이름이 name인 속성의 값을 value로 지정 ->모든 서블릿과 jsp가 공유할 수 있음 
★★getAttribute - (Object) 이름이 name인 속성의 값을 구함.
            지정한 이름의 속성이 존재하지 않을경우 null리턴
            꺼내올때 캐스팅 꼭 하기 
     ex)String type = (String)request.getAttribute("type");
☆setAttribute 용도 - 같은 영역의 페이지가 공유할 내용이 있으면 그걸 저장할 용도 (로그인할때 등)
0701\chap06\setApplicationAttribute.jsp

리퀘스트에 저장하면 하나의 url로 저장하는 모든 페이지에서 공유 가능
(=같은 리퀘스트로묶음)

<jsp:include> 액션태그 
<jsp:include page="sub.jsp" flush="false" />

리퀘스트 -> 두 jsp페이지를 한 url로 묶은걸 리퀘스트라고 함
묶는방법 -> <jsp:include> 액션태그 

<경로>
절대경로(앞에 /꼭 붙여주기) (웹콘텐츠는 진짜경로가 아니니까 지워야함) 
"/JinJSP/0701/img/images.jpg"
상대경로(파일이 있는곳이 아닌 폴더부터 시작)\
"../../img/images.jpg"

<jsp:param> 액션 태그
ex) 신규 파라미터 추가 
<jsp:include page="infoSub.jsp" flush="false">
	<jsp:param name="type" value="A" />
</jsp:include>                 //B로 바꾸면 B로바꿔서 가져옴
                            ★★//종료 / 꼭 붙이기!!  

<전달받은 파라미터를 한글로 출력할 수 있게함>
<%request.setCharacterEncoding("utf-8");%>

<파라미터값으로 보내기> -> 단 String밖에 안됨 
<jsp:include page="body_sub.jsp" flush="false">
	<jsp:param name="name" value="최범균" />
	<jsp:param name="name" value="최범균dd" />

parameter : 폼에 입력한 데이터/쿼리문자열로 전송된 데이터
            request에 담아서 보내는 값이라 set없음 
ex)
request.getParameter("name");

attribute : 속성. 기본객체에 직접 저장하는 값 
            setAttribute(String name, Object value)
공유하는 jsp에는->(원본타입)getAttribute(String name);

<include 디렉티브> ->두 파일 타입이 똑같아야함!! 
jspf파일을 jsp에 보내서 한꺼번에 실행함
(request는 실행 jsp에서 다른 jsp에 갔다가 실행jsp로 전달함)
jspf : 조각파일 확장자. 혼자 실행되는 파일이 아니고 
       다른 문서에 조각으로 들어가 실행되는 코드
       
★★<jsp:forward> 액션 태그   
<%@ page contentType = "text/html; charset=utf-8" %>
<%--
<jsp:foward> 액션 태그를 실행하면
생성했던 출력 결과는 모두 제거됨   

<%@ page contentType = "text/html; charset=utf-8" %>
<%@ page buffer="2kb" %>
-2kb면 플러쉬가 안돼서 제거되지 않고 나옴
-8kb면 플러쉬가 돼서 잘 제거 되고 연결된 페이지 글이 나옴

<경로>
<form action="<%= request.getContextPath() %>/0701/chap07/view.jsp">
같은 경로의 파일이면
<form action="view.jsp">

<%--jsp주석--%> : 주석 전송 안됨
<!--html주석--> : 주석전송됨(화면에만 보이지 않음)

에러 404 - 경로 에러

cookie와 session - 클라이언트의 상태값을 저장 
                   계속 유지하고 있어야 하는 값 

<cookie>
- 이름, 값으로 이루어짐 (필수)
- 유효시간 cookie.setMaxAge(0);
- 특정 도메인
- 쿠키 이름 : 알파벳, 숫자, _$가능 (_$로 시작불가)

www.naver.com

mail.naver.com/
cloud.naver.com/
calender.naver.com/

<cookie 경로>
모든 경로에 보내고싶을때 (/붙이기)
Cookie cookie3 = new Cookie("path3",
			URLEncoder.encode("경로:/", "utf-8"));
	cookie3.setPath("/");
	response.addCookie(cookie3);
	

<로그인만들기> jsp - chap09 - member 

<홈페이지 만들기>
주제 선정
기능분석 1. 로그인 1-1. id/pw 입력받는다.
                1-2. submit하기 전에 값이 입력됐는지 확인한다.
                1-3. ...
                
스토리보드 

★★★자바빈 만들때 컬럼이름과 변수명,타입까지 같아야 db가 이동함
1.
databean=DTO=VO=자바빈=CO => 데이터를 저장하는 용도
                         => 캡슐화 패턴 사용
     
2. DBBean => 하나의 객체로 여럿이서 씀(싱글턴패턴)
	public static LogonDBBean getInstance() {
		return instance;
	}
static메서드로 호출에서 만들어진 객체의 멤버들을 사용할수 있게

3. color파일같이 조각파일은 .jpf처리해주면 좋음 

로그인이 안된상태 -> session.getattribute(id)==null 

<% 자바코드 %> ->class나 jstl에 빼서 작성 
<%= 자바변수, 연산식, 메서드 호출 %> -> EL(값을 출력해서 화면에 출력하는)
<%@ 디렉티브 %>

JSP 15장 16장
<표현 언어>
- ★JSP의 네 가지 기본 객체가 제공하는 영역의 속성 사용
- 집합 객체에 대한 접근 방법 제공
- 수치 연산, 관계 연산, 논리 연산자 제공
- 자바 클래스 메서드 호출 기능 제공
- 표현언어만의 기본 객체 제공

<EL> ->getter가 없으면 사용할 수 없음.
(EL의 형태)
${} , #{}
<EL을 사용하면 코드를 짧게 쓸수 있음> 
ex)
<%=session.getAttribute("name")%> -> ${ name } 
 

<JSTL> 
C:set (EL에서 사용할 수 있는 변수를 선언하고 값 저장)
<c:set var="변수명" value="값"/> EL변수 선언, 값 저장 
ex)
<% 
    Member m = new Member();
    m.setName("이름1"); //set이랑 get이 있는 class가 있겠구나~예상
 m.->script내에서 사용 가능 
%>
<c:set var="m" value="<%= m %>" />
//"m“ el 내에서만 사용 가능 
<%-- 이 시점에는 값 생성하지 않음 --%>
<c:set var="name" value=“#{m.name}" />
// " value=“${m.name}" -> name이라는 변수를 사용하는 시점에 계산
                                   (주소만 저장하고 있는 개념)
ex)<c:set var="favoriateColor" value="#{pre.color}"/> 
	                            <!--              //pre 맵안의 key값을 가져와라 
	                                          지금은 없는데 나중에 "favoriateColor"라는 변수를 사용할때  -->                                   
//name이라는 변수를 사용하겠다
<% m.setName("이름2"); %> // m.setName script내에서 사용가능한 m
${name} <%-- 사용될 때 값 계산, "이름2" 출력 --%>
<% m.setName("이름3"); %>
${name} <%-- 사용될 때 값 계산, "이름3" 출력 --%>

★★★ value=“#{m.name} 에 #대신 $를 쓰면 저장 시점의 값이 저장댐

<EL의 기본객체> 
pageScope
requestScope
sessionScope
applicationScope
★★★ param : 요청 파라미터의 <파라미터 이름, 값> 매핑을 저장한 Map객체.

Map <k,v>
map.get(key);

 <%=map.get(key)%>(원래는 이렇게씀) 
1. ${map.key}┘ ->key를 써서 매핑돼 있는 값을 찾아옴
2. ★★★${param.id} ->전달받은 파라미터값중에 id라는 값에 매핑돼있는 값을 꺼내옴
 ${param.파라미터명} 
3. ${sessionScope.name} 
${sessionScope.속성명} ->session 영역의 Attribute에 매핑 된 객체를 참조하는 Map객체 
ex)${sessionScope.href} 
<a href="mgrserch.jsp?mgr=<%= dept.getMgr()%>"> 이면
"mgrserch.jsp?mgr=<%= dept.getMgr()%>"을 가져옴 
4. ${list.name} -> 이런식으로 쓰면 안됨(정수 값이 아닐 경우 에러 발생)
5. ${m.name} ->getter를 가지고 있을경우 getname을 호출함 (boolean같이 is일경우 isname불러옴) 

뒤에()붙어있으면 메서드임
el로 메서드도 호출 가능 
${null} -> 빈문자열 출력됨

폼에 입력해서 전송한 값 -> 파라미터값 
같은 영역에있는 페이지들끼리 공유될값을 속성으로 저장 - Attribute값 
href을 속성명이라고 하고 =뒤에 있는게 값

<연산자>
※ 수치 연산자 
   +, -, *, / 또는 div, % 또는 mod
※ 비교 연산자
   == 또는 eq, != 또는 ne
   < 또는 lt, <= 또는 le, > 또는 gt, >= 또는 ge
※ 논리 연산자
   && 또는 and
   || 또는 or
   ! 또는 not  
※ empty 연산자  ->if문 안에서 많이 사용
   empty <값>
   값이 null이면, true
   값이 빈 문자열("")이면, true
   값의 길이가 0인 배열이나 콜렉션이면 true
   이 외의 경우에는 false
※ 비교 선택 연산자
   <수식> ? <값1> : <값2>
   
   https://mvnrepository.com/
   jar파일 모아놓은곳 
   
   JSTL
   <% 자바코드 %> -> class,JSTL
   
   for -> custom tag   ->많이 쓰는것들을 스탠다드형으로 만들어둔 태그 
   
★★★   
if
foreach
choose

<국제화> -> 사용 언어에 따라 저절로 언어를 바꿔줌 
(언어를 모아놓은 걸 번들이라고 함)
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
포맷할경우 맨위에 이거 써줘야됨

ex) message_ko.properties
<properties파일>
1. 언더바뒤의 ko는 파일 이름이 아님
2. 프로퍼티스 파일은 영어만 쓸 수 있음
 
-리소스 번들 번위에서 메시지 읽기
<fmt:bundle basename="resource.message" [prefix="접두어"]>
    <fmt:message key="GREETING" />
</fmt:bundle>

★date time format 
ex) 
<%@ page contentType = "text/html; charset=utf-8" %>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head><title>numberFormat 태그 사용</title></head>
<body>

<c:set var="now" value="<%= new java.util.Date() %>" />
<fmt:formatDate value="${now}" type="date" dateStyle="full" /> <br>
<fmt:formatDate value="${now}" type="date" dateStyle="short" /> <br>
<fmt:formatDate value="${now}" type="time" timeStyle="full"/> <br>
<fmt:formatDate value="${now}" type="time" timeStyle="short" /> <br>
<fmt:formatDate value="${now}" type="both" 
                dateStyle="full" timeStyle="full" /> <br>
<fmt:formatDate value="${now}" pattern="z a h:mm" /> <br>

</body>
</html>

length(str1) = ${fn:length(str1)} <br>

toUpperCase(str1) = "${fn:toUpperCase(str1)}" <br>
toLowerCase(str1) = "${fn:toLowerCase(str1)}" <br>
substring(str1, 3, 6) = "${fn:substring(str1, 3, 6)}" <br>
//1번 문장 3번인덱스부터 6번인덱스 앞까지 
substringAfter(str1, str2) = "${fn:substringAfter(str1, str2)}" <br>
substringBefore(str1, str2) = "${fn:substringBefore(str1, str2)}" <br>
trim(str1) = "${fn:trim(str1)}" <br>
//앞뒤 공백 제거 
replace(str1, src, dest) = "${fn:replace(str1, " ", "-")}" <br>
//공백을 하이픈으로 바꾸겠다 
indexOf(str1, str2) = "${fn:indexOf(str1, str2)}" <br>
//사용이라는 문자열의 시작지점 
startsWith(str1, str2) = "${fn:startsWith(str1, 'Fun')}" <br>
//str1문이 fun이라는 문자열로 시작하는지 ->true
endsWith(str1, str2) = "${fn:endsWith(str1, "합니다.")}" <br>
//str1문이 합니다.로 끝나는지 틀리면 ->false
contains(str1, str2) = "${fn:contains(str1, str2)}" <br>
//str1안에 str2가 포함하는지  (대소문자 구별)
containsIgnoreCase(str1, str2) = "${fn:containsIgnoreCase(str1, str2)}" <br>
//대소문자 무시하고 포함하고있는지 
<c:set var="array" value="${fn:split(tokens, ',')}" />
//토큰으로 나눈걸 array라는 배열에 저장함
join(array, "-") = "${fn:join(array, "-")}" <br>
//배열에 들어간걸 -으로 나눠서 보여줌 
escapeXml(str1) = "${fn:escapeXml(str1)}" <br>
//페이지 소스보기로 봐야함 <>의 기호가 특수문자로 바뀌어있음 

<파일 업로드>

★★POST 방식에서 enctype을 multipart/form-data로 설정
type 속성이 file인 <input> 태그를 통해 파일 선택
(파일 내용도 같이 보내려면 꼭!!!)
ex)
<form action="..." method="post" enctype="multipart/form-data">
     ...
    <input type="file" name="file1" />
</form>

Fileupload API
파일 업로드
일반 파라미터 : 파라미터 이름/ 값
파일 파라미터 : 파라미터 이름/파일이름/파일 타입/내용

파라미터 -> List<FileItem> (파라미터 수만큼 생기는데 list로 묶기) 

<보여줄 글이 있는지 없는지 체크하는 getter> 
public boolean isHasPdsItem() { //isHas가 있으니까 boolean값을 리턴하는 getter라고 볼수 있음 
		return ! pdsItemList.isEmpty();
	}

인터페이스 구현 -> 조상이 가지고있는 모든걸 물려받아서 
오버라이딩 해서 구현한것 

<★필터 web.xml에 등록해서 쓰는 방법>
<web-app ...>
    
    <filter>
        <filter-name>FilterName</filter-name>
        <filter-class>javacan.filter.FileClass</filter-class>                             //패키지명부터 파일 이름까지
        <init-param>
           <param-name>paramName</param-name>
           <param-value>value</param-value>
        </init-param>
    </filter>
     
    <filter-mapping>
        <filter-name>FilterName</filter-name>
        <url-pattern>*.jsp</url-pattern>
    </filter-mapping>
    
    ...
</web-app>

<★리스너 클래스 등록>
<web-app ...>
    <listener>
        <listener-class>kame.jdbc.loader.DBCPInitListener</listener-class>
    </listener>

    <listener>
        <listener-class>kame.chap22.CodeInitListener</listener-class>
    </listener>
    ...
</web-app> 

디자인 패턴 - 한줄 정의 설계 문제의 해답을 문서화하기 위해 고안된 형식
방법. 과거 소프트웨어 개발 과정에서 발견된 설계 노하우를 축적하고 
이름을 붙여 재사용하기 좋은 형태의 특정 규약으로 묶어 정리한 것 

servelet(서블릿) : 웹 요청을 처리하는 클래스

폼태그에 메서드:post라고 썼을때만 post 방식 

조상타입의 참조변수로 자손의 객체를 다룸 
CommandHander c = new ListHandler()
CommandHander c = new WriterFormHandler()

<url 요청하는 법>
	@Override
	public String process(HttpServletRequest request, HttpServletResponse response) throws Throwable {
		request.setAttribute("hello", "안녕하세요!");
		request.getSession().setAttribute("memId", "id값");
		return "/view/hello.jsp";
		
<WebServlet설정>
@WebServlet(urlPatterns = "*.do", initParams = {		
@WebInitParam(name = "configFile2",        
value = "/WEB-INF/commandHandler.properties") }),
@WebInitParam(name = "configFile3", 
value = "/WEB-INF/commandHandler.properties") }),
@WebInitParam(name = "configFile4", 
value = "/WEB-INF/commandHandler.properties") }), (컴마찍고 여러개의 파라미터를 한번에 보낼 수 있다.)

게시판
기능 - 요청 uri- 실행할 클래스 명
list(목록) - list.do라고만 써도 페이지가 나옴
여기에 listAction을 쓰면 페이지가 나오면서 나올 액션까지도 지정 가능
그 다음 나올 페이지 list.jsp까지 작성하면 좋음   
content(상세보기)
writeForm
writepro
updateForm
updatePro
deleteForm
deletePro

<만드는 순서> 
디비빈 dao는 미리 만들어놓고
얘네를 구현할 조상 클래스와
각각의 클래스를 만들고 프로퍼티스 파일에 요청할것들을 모아서
써놓기 (주소 작성할 때 프로젝트명만 뗀 주소로 작성)
요청이 정해지면 컨트롤러 ->컨트롤러를 언제실행할건지 작성
-> 뷰작성 

MVC C-> path에서 contextroot를 제외한 부분 
       ->M : 비지니스 로직
             화면에 보일 데이터 request, session 저장
                setAttribute("이름",값);
                view 경로 리턴
                - WebContent폴더 아래 JSP파일 경로
        V -> JSP 화면 구현
            -html코드, css, js
            -request,session에 저장된 데이터
                    ${이름}
            -JSTL<c:if>,<c:forEach>,<c:choose> 
            
            
<경로>
do가져올땐 - 프로젝트부터
jsp 가져올땐 - 웹컨텐츠 안 폴더이름부터 

기능 - 요청 uri - model클래스 - jsp 
list/MVC/list.do - ListAction - List.jsp

do로 경로를 쓰면 컨트롤러가 받아서 실행함 

Project 생성

컨트롤러
model클래스 생성

action은 항상 jsp 파일을 리턴함 웹컨텐츠 아래부터 /같이 쓰기 

<모델 2 만들때 필수>
1. web.xml
2. CommandAction
3. ControllerUsingURI
4. 프로젝트만들고
5. java 만들때 add command action
6. index 만들기  

<스프링 mybatis 설치> 마이바티스 
POJO

ORM 프레임워크(Oject-Relational-Mapping)
:DB 연동을 쉽게할 수 있게 한 프레임 워크 

maven/gradle

*jar파일에 문제 생기면 .m2폴더를 삭제하고 다시 껐다 키면 됨

*메이븐 사용하려면 jdk설치시 자바홈 환경변수 경로 해줄것

SqlSession - sql문 실행 

selectOne
selectList (여러개 가져올때)
insert
update
delete

<config.xml>
	<settings>
		<setting name="jdbcTypeForNull" value="NULL" />
	</settings>         //null값도 쓰겠다 
	
<typeAliases>
타입 별칭은 자바 타입에 대한 좀더 짧은 이름이다. 오직 XML 설정에서만 사용되며, 타이핑을 줄이기 위해 존재한다.
예를들면:
<typeAliases>
<typeAlias alias="Author" type="domain.blog.Author"/>
<typeAlias alias="Blog" type="domain.blog.Blog"/>
<typeAlias alias="Comment" type="domain.blog.Comment"/>
<typeAlias alias="Post" type="domain.blog.Post"/>
<typeAlias alias="Section" type="domain.blog.Section"/>
<typeAlias alias="Tag" type="domain.blog.Tag"/>
</typeAliases>	
                                          //여러개 가져올땐 클래스
<insert id="insertAuthor" parameterType="domain.blog.Author">
insert into Author (id,username,password,email,bio)
values (#{id},#{username},#{password},#{email},#{bio})
</insert>
                                        //가져올게 한개일때 
<delete id="deleteAuthor” parameterType="int">
delete from Author where id = #{id}
</delete>

28페이지 자바 sql 

dao -sql실행하는 

실행순서 
config에서 
db를 쓰고
config는 커넥션 풀 역할
deptMapper에있는 sql문의 아이디를  
dao에서 쓴다
sqlsession이랑 dao를 service에서씀
service에서 쓴거를 main에 정리해서 사용(main은 최대한 

main - service - dao 

sql 세션 sql을 실행시키는애
펙토리 메이크를 만들어야 dao에서 팩토리를 쓸수있음 

오픈세션을 해야 sql세션을 오픈할수 있음 
x는 변경된 레코드 갯수
셀렉 제외한 모든애들은 갯수가 변함

parameterType = 내가 입력할값이 있을때
resultType = select에만 씀  

where 컬럼명 like concat('%',#{keyword},'%') 

dao에서 int를 쓰는거 셀렉빼고 모두 
셀렉도 한개이면 deptdto 여러개이면 리스트 

Mapper파일 작성
<select id parameterType="" resultType>
★★★ parameterType="객체"-> #{변수이름}
"map" -> #{key}
"원시타입"(값이 한개만 전달될때) -> #{이름}


<sqlsession 메소드>
update
insert
delete
selectone
selectlist

<select id="selectOne" parameterType="int" resultType="Map">

select ename from emp where empno=#{no}
</select>

if는 where절에서 사용 
ex)
<where>
<if test ="no!=null">
    AND|OR
</if>
</where>

<select id="sal"resultType="">
select * from emp where sal>=3000     ->부등호 사용시 태그와겹침
이때 <![CDATA[]]> 안에 쿼리문 써줌
</select> 

웹앱 폴더엔안에 폴더만들어서 jsp파일 넣기

스프링다운
https://spring.io/tools 여기서 다운로드하고 jar압축풀고 컨텐츠 압축 풀고 exe파일 실행 
help - 이클립스마켓 - spring3 검색- 스프링 툴 3.9.13 인스톨
설치하고 동의하고 finish
재시작
파일-new- other - 스프링 있나 확인
maven 프로젝트 만들기 
-------------------------------------------
정민이꺼 
https://spring.io/tools 툴 설치
help - eclipse marketplace
- Spring Tools Add-On for Spring Tools 4 3.9.13 RELEASE 설치.

1. Lombok v1.18.4.jar 파일 실행
2. sts-4.7.0.RELEASE 폴더 안에 spring 경로 잡아주고 install
--------------------------------------------
<DItest.xml>

https://mvnrepository.com/search?q=spring+context에서
spring context검색 
Spring Context ≫ 4.3.27.RELEASE 소스저장해놓고 
dependencies 눌러서 
<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>4.3.27.RELEASE</version>
</dependency>
맞춰서 3개 넣어주고 추가해주면 
pom.xml에 추가돼있음 

	<bean id="bar" class="spring.DI.Bar" />
	<bean id="baz" class="spring.DI.Baz" />

	<bean id="f1" class="spring.DI.Foo">
		<lookup-method name="getBaz" bean="baz" />
	</bean>

	<bean id="foo" class="spring.DI.Foo" p:bar-ref="bar"
		p:baz-ref="baz" p:str="hello" p:i="10" />


	<bean id="col" class="spring.DI.CollectionEx">
		<property name="greeting">
			<list>
				<value>hello</value>
				<value>안녕하세요</value>
			</list>
		</property>

		<property name="names">
			<map>
				<entry key="1">
					<value>김자바</value>
				</entry>
				<entry key="2">
					<value>이자바</value>
				</entry>
			</map>
		</property>

		<property name="props">
			<props>
				<prop key="ip">localhost</prop>
				<prop key="port">8080저장</prop>

			</props>


		</property>
</bean>

interface A{}

class B implements A{}
class C implements A{}

class D extends B{} 
//A와 D도 상속관계임 

@Setter
class Test{
    private A a;  //A를 객체로 만들수 없으니까 B,C,D를 가져와서 
                //객체로 만들 수 있음 
    }
    <bean class="B" id="b"> 
                            //이경우는 B를 저장함(A와 가장 가까워서)
    <bean class="D" id="d"> //이게 C면 에러발생함 
    <bean class="Test" id="t" autowire="byType">
    
<Annotation으로 bean 추가하는 법> 
@Repository - DAO클래스
@Component  -일반클래스를 bean으로 만들때
 org.springframework.stereotype.Component ->이걸 붙이면
 -자동으로 빈으로 등록되게 함
 -빈의 이름은 첫 문자만 소문자이고 나머지는 클래스 이름과 동일
 -빈의 이름을 지정해 주려면 @Component("myFoo");
 -@Scope("prototype")으로 빈의 범위를 지정할 수 있음
 -org.springframework.context.annotation.Scope //scope 쓰려면 써주기
 @Service -서비스 클래스
 @Controller -웹프로젝트 시 컨트롤러클래스
 
 
 @Configuration  ->      @Bean과 같이 쓰임 (@Component도)
   
public class Foobar {
	
	@Bean(name="scottFoo")         ->bean을 부분적으로 쓰고싶을때
	public Foo activeFoo() {
		Foo foo = new Foo();
		foo.setName("Scott");
		return foo;
	}

}

@Required 
	@Autowired  (@Required 가 포함돼있음)
	
	
	
주입받을때
기본형 String 은 value로 받아와야함
("bin/")
객체면 auto,또는 리소스  

bean -> 리턴한걸 bean으로 추가한거고 
bean을 안쓰고 component만 쓰면 클래스 전체가 bean 

bean
XML
<bean id class>
의존관계 
<property name="(setter를 가지고있는)변수명">
                (변수가 아니면)<ref bean="빈id">
</property>

1. bean 생성
<context:component-scan base-package="패키지명" />
클래스명 -> @Component, @Controller, @Servoce @Repository
클래스명 -> @Configuration, 메서드 -> @Bean
2. 의존 객체를 주입하는 @(어노테이션)
<context:annotation-config />
@Autowire : 컨테이너에 있는 bean 중에서 같은 타입 or 자손타입의 객체를 주입
@Resource

3. Spring/기본형 데이터 주입 @
@Value("값")
	
	
-------------------------------------------------------
<스프링 db 연동><pom.xml에 넣어주기>
1. 코드넣기
mysql connector  
commons dbcp2
mybatis
mybatis spring
spring orm

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>spring.sample</groupId>
  <artifactId>SpringEx1</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <dependencies>
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-context</artifactId>
  		<version>4.3.27.RELEASE</version>
  	</dependency>
  	<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.12</version>
    <scope>provided</scope>
    <optional>true</optional>
</dependency>

<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.21</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-dbcp2 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-dbcp2</artifactId>
    <version>2.7.0</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.5</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>2.0.5</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.springframework/spring-orm -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
    <version>4.3.27.RELEASE</version>
</dependency>

  	
  </dependencies>
</project>


2. Mapper파일 작성



parameterType="spring.mybatis.MemDto
parameterType이 있을경우 
return session.insert("mem.insert",dto);
보내는 매개변수가 2개여야됨 


dept

dto
dao
service 

1.selectlist 전체부서출력
2.selectOne 부서번호 선택 - 해당 부서 정보출력
3.insert 부서번호는 자동으로(기존 부서번호 max+10)
  부서명,위치입력후 저장
4.update 부서번호, 수정할 위치 입력받아서 수정
5.delete '

도토리 안뜰때 -market에서
Spring Tools 3 Add-On for Spring Tools 4 
재설치 

<AOP 주요용어>
-Advice : 언제 공통 관심 기능을 핵심 로직에 적용할 지를 정의하고 있다. 
예를 들어, '메서드를 호출하기 전'(언제)에 'Transaction을 시작한다'(공통 기능) 기능을 적용한다는 것을 정의하고 있다.
-Joinpoint : Advice를 적용 가능한 지점. 메서드 호출, 필드 값 변경 등Joinpoint에 해당한다.
-Pointcut : Joinpoint의 부분 집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타낸다. 
-Weaving : Advice(공통 Code )를 핵심 로직 Code에 적용하는 것을 weaving이라고 한다. 
-Target object : 하나 또는 그 이상의 Aspect에 의해 Advice되는 객체, 즉 핵심 로직을 구현하는 클래스를 의미한다. 스프링에서는 런타임 프록시를 사용해 구현됨
-Aspect : 여러 객체에 공통으로 적용되는 공통 관심 사항을 Aspect라고 한다. 
	 Transaction이나 Security 등이 Aspect의 좋은 예이다.

<AOP사용법>
어떤클래스를 aspect로 쓸건지
어떤 핵심 로직을 쓸건지 
어디 앞뒤로 사용할건지

뷰는 컨트롤러를 거쳐서 실행해야함 

<여러개 쓸 경우>
<init-param>
	<param-name>contextConfigLocation</param-name>
	<param-value>/WEB-INF/main.xml,/WEB-INF/bbs.xml</param-value>
	</init-param>                //쉼표 (띄어쓰기x)

[자바 정민] [오후 2:49] web.xml
 - DispatcherServlet 등록
 - 사용할 스프링 설정파일 지정 - 생성
 - CharacterEncodingFilter 등록
 
Controller
 - 파라미터(from 데이터) 저장
1. 컨트롤러 메서드의 매개변수에 자바빈 타입의 변수 선언
(자바빈 클래스의 변수명==파라미터이름) 
2. 파라미터의 이름과 같은 이름의 매개변수 선언
★★★★★3. @RequestParam("파라미터 이름")
4. HttpServletRequest타입의 매개변수 선언 후
Request.getParameter("이름") 사용(추천x)
 - view 지정
 - String 타입 리턴 - 리턴 값:view name
 - ModelAndView생성자의 첫번째 매개변수 - view name
 new ModelAndView("view name") 
1.
2.
3. 
4. 
 - model데이터 추가
1. 컨트롤러메서더의 매개변수에 저장된 자바빈 객체(파라미터값이 저장되
2.
3.
4.

1. D.s가 NewArticleCommand 객체 생성 후 command에 저장
2. 전송된 파라미터값을 command의 변수에 저장
(이름이 같으면 setter를 통해서 저장됨)
3.@ModelAttribute
파라미터값이 저장된 NewArticleCommand객체를 command라는 이름으로
model에 add
(view에서 command라는 이름으로 사용할 수 있다.) 

server - web.xml
encoding 필터
dispatcherservlet - 웹 컨테이너 등록 - 설정파일 

controller
bean  
viewresolver
HandlerMapping(default

★★★★MVC 동작 방식 외우기(설명할 수 있게) 스프링 프레임워크 mvc ppt

컨트롤러
Http메서드 |URI | 메서드
get |/hello | HelloController.hello()
post |/hell| HelloController.doHello()

405 - 해당 요청방식을 지원하지않을때
400 - 파라미터 값 저장시 타입 믹스매치
입력한 값 체크해볼것

@RequestMapping("/test")
public String test(Model m){
m.addAttribute("이름",데이터); ->view전달 
return viewname;
}

쿠키는 클라이언트의 브라우저에 저장됨 

<외우기>
 뷰 이름 지정(명시)

-리턴타입이 ModelAndView
mav.setViewName(“viewname");  
ModelAndView(“viewname”)

-리턴타입이 String 
return “viewname"  

뷰 이름 자동 지정  
-리턴 타입이 Model이나 Map인 경우  리턴 타입이 void이면서 ServletResponse 또는 HttpServletResponse 타입의 파라 미터가 없는 경우  

-요청 URI에서 맨 앞 /와 확장자를 제외한 나머지 부분이 사용 
 /search/game2.do -> search/game2 

리다이렉트  뷰  : 이름에  redirect: 접두어를 붙이면 리다이렉트 됨

1. 매개변수
2. @ModelAttribute 메서드 -> 리턴 객체를 모델로 추가
@ModelAttribute 매개변수 -> 이름 지정
3. @RequestMapping 메서드
 1) 매개변수로 Map,Model,ModelMap 선언   -->이게 가장 많이씀 
    Map.put("이름",값);
    Model,addAttribute("이름",값);
 2) 리턴타입 Map,Model,ModelMap 선언
 Map,Model,ModelMap 구현 객체 생성

---->리턴한 객체가 모델데이터가 됨 (뷰네임 설정안하면 자동으로 매핑됨)

 3) 리턴 타입 ModelAndView
 ModelAndView 객체 생성  하는법 3가지 
 new ModelAndView(); 
 
 ModelAndView.setViewName("viewname");
 ModelAndView.addObject("modelname",data);
 
 new MdoelAndView("view name");
 ModelAndView("view name","modelname", data);
                     뷰네임        모델 네임 
                     
                     
--------------------------------------------------------
클라이언트가 "/search/main.do"를 요청하면 dispatcher servlet에서
handlerMapping 실행하는데 ModelAttribute가 먼저 실행됨 
컨트롤러에 요청해서 모델이랑 뷰네임을 가져옴
뷰네임만 뷰네임리졸버로 보내서 해당하는 뷰객체를 다시 dispatcher servlet
로 보내고 모델 객체를 dispatcher servlet에 보내서 클라이언트로보냄
---------------------------------------------------------------  

이닛바인더 -> 모델어트리뷰트 -> 로긴 커맨드 객체 만들고 
모델 객체 추가하는데 이름 로그인 커맨드

post로 전송하는 매핑 
로그인 커맨드로 된 객체 추가 이름은 소문자l(1/모델데이터랑 이름이 같으니까
같은걸 집어넣음)
2/전송받은 파라미터 값 저장 

reject- 글로벌 에러를 추가함 

<input type = "file" name="file">
MultipartFile 변수 저장
MultipartFile[]

@ResponseBody
메서드가 리턴한 객체를 response에 담아서 client에 전송함
(view를 사용하지 않음) 

scan을 쓰면 어노테이션을 붙여줘야하고 
<bean~ > 을 넣어주면 어노테이션 안붙여줘도 됨  
<bean id="fileInfoDao" class="spring.service.FileInfoDao">
		<property name="sqlSessionFactory">
			<ref bean = "sqlSessionFactory"/>
		</property>
		이거는 sqlSessionFactory을 

컬럼이 두개일땐 map 좋음 
가격과 수 짝지어서 저장됨
나중에 key로 get해서 쓰기

                     
@RequestBody : request로 전달되는 값을 받아옴
@ResponseBody : 리턴값을 response에 저장-client에게 전달됨
@RestController = @Controller + @ResponseBody 

* 파라미터 이름과 매개변수의 이름이 같으면 알아서 알아들음 

모델만드는법
1. 매개변수에 맵이나 모델이나 모델맵타입 선언
거기에 저장하면 자동으로 모델이 됨
메소드는 addattribute
                    
2. 모델앤뷰 만들어서 (꼭 리턴타입으로하기) 
3. 리턴타입에 맵이나 모델 지정해서
4. 생성자로 
5. 메서드에 모델 attribute 어노테이션을 붙임
(이때 이름 안붙이면 리턴타입을 소문자로 바꿔서 이름으로 삼음) 
responsebody 리스폰즈에 담긴 내용 그대로 화면에 전달됨

★★★★★★
@Controller
public class DownloadController implements ApplicationContextAware {
private WebApplicationContext context = null;
@RequestMapping("/file")
public ModelAndView download() throws Exception {
File downloadFile = getFile();
return new ModelAndView
("download", "downloadFile", downloadFile);
} 첫번째꺼 뷰네임 두번째꺼 모델네임 세번째꺼 모델 데이터
                     
Tiles 3점대 받기(스프링 개발용) (2점대는 웹개발용) 
https://mvnrepository.com/artifact/org.apache.tiles/tiles-jsp